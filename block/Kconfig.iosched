if BLOCK

menu "IO Schedulers"

config IOSCHED_BFQ
	tristate "BFQ I/O scheduler"
	default y
	---help---
	  BFQ is a proportional-share storage-I/O scheduling algorithm based on
	  the slice-by-slice service scheme of CFQ. But BFQ assigns budgets,
	  measured in number of sectors, to processes instead of time slices. The
	  device is not granted to the in-service process for a given time slice,
	  but until it has exhausted its assigned budget. This change from the time
	  to the service domain allows BFQ to distribute the device throughput
	  among processes as desired, without any distortion due to ZBR, workload
	  fluctuations or other factors. BFQ uses an ad hoc internal scheduler,
	  called B-WF2Q+, to schedule processes according to their budgets. More
	  precisely, BFQ schedules queues associated to processes. Thanks to the
	  accurate policy of B-WF2Q+, BFQ can afford to assign high budgets to
	  I/O-bound processes issuing sequential requests (to boost the
	  throughput), and yet guarantee a low latency to interactive and soft
	  real-time applications.
	  
config IOSCHED_FIFO
	tristate "FIFO I/O scheduler"
	default y
	---help---
	  A relatively simple io schedulers that does what has been described.
	  It is also known as FCFS (First come first serve) but this really isn't true.
	  It does basic sorting; sorting the processes according to the appropriate
	  order and nothing else. In other words, it is quite similar to noop. 
  
config IOSCHED_FIOPS
	tristate "FIOPS I/O scheduler"
	default y
	---help---
	  This new I/O scheduler is designed around the following assumptions 
	  about Flash-based storage devices: no I/O seek time, 
	  read and write I/O cost is usually different from rotating media,
	  time to make a request depends upon the request size, 
	  and high through-put and higher IOPS with low-latency.
	  
config IOSCHED_SIO
	tristate "Simple I/O scheduler"
	default y
	---help---
	  scheduler is based on the deadline scheduler but it's more like a mix 
	  between no-op and deadline.In other words, SIO is like a lighter version
	  of deadline but it doesn't do any kind of sorting, 
	  so it's aimed mainly for random-access devices (like SSD hard disks)
	  where request sorting is no needed (as any sector can be accesed
	  in a constant time, regardless of its physical location).
	  
config IOSCHED_VR
	tristate "VR I/O scheduler"
	default y
	---help---
	  Unlike other scheduling software, synchronous and asynchronous requests
	  are not handled separately, but it will impose a fair and balanced within
	  this deadline requests, that the next request to be served is a function 
	  of distance from the last request. The VR is a very good scheduler with elements
	  of the deadline scheduler. He will probably be the best for MTD Android devices.
	  He is the one who can make the most of the benchmark points, but he is also an 
	  unstable schedulers, because his performance falter. Sometimes they fluctuate 
	  below the average, sometimes it fluctuates above the average, 
	  but if above, then he is the best. 
	  
config IOSCHED_ZEN
	tristate "ZEN I/O scheduler"
	default y
	---help---
	  Based on the VR Scheduler. It's an FCFS (First come, first serve) based algorithm.
	  It's not strictly FIFO. It does not do any sorting. It uses deadlines for fairness,
	  and treats synchronous requests with priority over asynchronous ons. 
	  Other than that, pretty much the same as no-op.
	  
config IOSCHED_NOOP
	bool
	default y
	---help---
	  The no-op I/O scheduler is a minimal scheduler that does basic merging
	  and sorting. Its main uses include non-disk based block devices like
	  memory devices, and specialised software or hardware environments
	  that do their own scheduling and require only minimal assistance from
	  the kernel.

config IOSCHED_DEADLINE
	tristate "Deadline I/O scheduler"
	default y
	---help---
	  The deadline I/O scheduler is simple and compact. It will provide
	  CSCAN service with FIFO expiration of requests, switching to
	  a new point in the service tree and doing a batch of IO from there
	  in case of expiry.

config IOSCHED_ROW
	tristate "ROW I/O scheduler"
	---help---
	  The ROW I/O scheduler gives priority to READ requests over the
	  WRITE requests when dispatching, without starving WRITE requests.
	  Requests are kept in priority queues. Dispatching is done in a RR
	  manner when the dispatch quantum for each queue is calculated
	  according to queue priority.
	  Most suitable for mobile devices.

config IOSCHED_CFQ
	tristate "CFQ I/O scheduler"
	# If BLK_CGROUP is a module, CFQ has to be built as module.
	depends on (BLK_CGROUP=m && m) || !BLK_CGROUP || BLK_CGROUP=y
	default y
	---help---
	  The CFQ I/O scheduler tries to distribute bandwidth equally
	  among all processes in the system. It should provide a fair
	  and low latency working environment, suitable for both desktop
	  and server systems.

	  This is the default I/O scheduler.

	  Note: If BLK_CGROUP=m, then CFQ can be built only as module.

config CFQ_GROUP_IOSCHED
	bool "CFQ Group Scheduling support"
	depends on IOSCHED_CFQ && BLK_CGROUP
	default n
	---help---
	  Enable group IO scheduling in CFQ.

config IOSCHED_SIO
       tristate "Simple I/O scheduler"
       default y  
       help
         The Simple I/O scheduler is an extremely simple scheduler,
         based on noop and deadline, that relies on deadlines to
         ensure fairness. The algorithm does not do any sorting but
         basic merging, trying to keep a minimum overhead. It is aimed
         mainly for aleatory access devices (eg: flash devices).

choice
	prompt "Default I/O scheduler"
	default DEFAULT_CFQ
	help
	  Select the I/O scheduler which will be used by default for all
	  block devices.

	config DEFAULT_BFQ
		bool "bfq" if IOSCHED_BFQ=y

	config DEFAULT_FIFO
		bool "fifo" if IOSCHED_FIFO=y

	config DEFAULT_FIOPS
		bool "fiops" if IOSCHED_FIOPS=y

	config DEFAULT_SIO
		bool "sio" if IOSCHED_SIO=y

	config DEFAULT_VR
		bool "vr" if IOSCHED_VR=y

	config DEFAULT_ZEN
		bool "zen" if IOSCHED_ZEN=y
		
	config DEFAULT_DEADLINE
		bool "Deadline" if IOSCHED_DEADLINE=y

	config DEFAULT_ROW
		bool "ROW" if IOSCHED_ROW=y
		help
		  The ROW I/O scheduler gives priority to READ requests
		  over the WRITE requests when dispatching, without starving
		  WRITE requests. Requests are kept in priority queues.
		  Dispatching is done in a RR manner when the dispatch quantum
		  for each queue is defined according to queue priority.
		  Most suitable for mobile devices.

	config DEFAULT_CFQ
		bool "CFQ" if IOSCHED_CFQ=y

	config DEFAULT_NOOP
		bool "No-op"

endchoice

config DEFAULT_IOSCHED
	string
	default "bfq" if DEFAULT_BFQ
	default "fifo" if DEFAULT_FIFO
	default "fiops" if DEFAULT_FIOPS
	default "sio" if DEFAULT_SIO
	default "vr" if DEFAULT_VR
	default "zen" if DEFAULT_ZEN
	default "deadline" if DEFAULT_DEADLINE
	default "row" if DEFAULT_ROW
	default "cfq" if DEFAULT_CFQ
	default "noop" if DEFAULT_NOOP
	default "sio" if DEFAULT_SIO
endmenu

endif
